/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICategoryClient {
    get(): Observable<CategoryVM>;
}

@Injectable({
    providedIn: 'root'
})
export class CategoryClient implements ICategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<CategoryVM> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CategoryVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<CategoryVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CategoryVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryVM>(<any>null);
    }
}

export interface IClientClient {
    getClientsForBusiness(businessId: string): Observable<ClientVM>;
    getClientsForBusiness2(businessId: string): Observable<ClientVM>;
    create(command: CreateClientCommand): Observable<ResponseModelGuid>;
    update(command: UpdateClientFoodCommand): Observable<ResponseModel>;
    get(clientId: string | undefined): Observable<ClientByIdVM>;
    update2(id: string, command: UpdateClientCommand): Observable<ResponseModelGuid>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ClientClient implements IClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        // this.baseUrl = baseUrl ? baseUrl : "";
        this.baseUrl = "https://app.nutrientcalc.com";
    }

    getClientsForBusiness(businessId: string): Observable<ClientVM> {
        let url_ = this.baseUrl + "/api/Client/business/{businessId}";
        if (businessId === undefined || businessId === null)
            throw new Error("The parameter 'businessId' must be defined.");
        url_ = url_.replace("{businessId}", encodeURIComponent("" + businessId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientsForBusiness(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientsForBusiness(<any>response_);
                } catch (e) {
                    return <Observable<ClientVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientVM>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientsForBusiness(response: HttpResponseBase): Observable<ClientVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientVM>(<any>null);
    }

    getClientsForBusiness2(businessId: string): Observable<ClientVM> {
        let url_ = this.baseUrl + "/api/Client";
        if (businessId === undefined || businessId === null)
            throw new Error("The parameter 'businessId' must be defined.");
        url_ = url_.replace("{businessId}", encodeURIComponent("" + businessId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientsForBusiness2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientsForBusiness2(<any>response_);
                } catch (e) {
                    return <Observable<ClientVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientVM>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientsForBusiness2(response: HttpResponseBase): Observable<ClientVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientVM>(<any>null);
    }

    create(command: CreateClientCommand): Observable<ResponseModelGuid> {
        let url_ = this.baseUrl + "/api/Client";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModelGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModelGuid>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseModelGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModelGuid>(<any>null);
    }

    update(command: UpdateClientFoodCommand): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/Client";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    get(clientId: string | undefined): Observable<ClientByIdVM> {
        let url_ = this.baseUrl + "/api/Client/clientId?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientByIdVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientByIdVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientByIdVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientByIdVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientByIdVM>(<any>null);
    }

    update2(id: string, command: UpdateClientCommand): Observable<ResponseModelGuid> {
        let url_ = this.baseUrl + "/api/Client/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate2(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModelGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModelGuid>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate2(response: HttpResponseBase): Observable<ResponseModelGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModelGuid>(<any>null);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Client/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IClientFoodClient {
    get(clientId: string | null | undefined): Observable<ClientFoodVM>;
    create(command: CreateClientFoodCommand): Observable<ResponseModel>;
    update(command: UpdateClientByUserId): Observable<ResponseModelGuid>;
    getWithDetails(clientId: string | null | undefined): Observable<ClientFoodDetailedVM>;
    get2(category: string | null, key: string | null | undefined): Observable<FoodBasicVM>;
    update2(type: string | null, command: UpdateClientStatus): Observable<ResponseModelGuid>;
    delete(id: number): Observable<FileResponse>;
    getClientReport(clientId: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ClientFoodClient implements IClientFoodClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        // this.baseUrl = baseUrl ? baseUrl : "";
        this.baseUrl = "https://app.nutrientcalc.com";
    }

    get(clientId: string | null | undefined): Observable<ClientFoodVM> {
        let url_ = this.baseUrl + "/api/ClientFood?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientFoodVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientFoodVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientFoodVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFoodVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFoodVM>(<any>null);
    }

    create(command: CreateClientFoodCommand): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/ClientFood";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    update(command: UpdateClientByUserId): Observable<ResponseModelGuid> {
        let url_ = this.baseUrl + "/api/ClientFood";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModelGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModelGuid>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModelGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModelGuid>(<any>null);
    }

    getWithDetails(clientId: string | null | undefined): Observable<ClientFoodDetailedVM> {
        let url_ = this.baseUrl + "/api/ClientFood/withdetails?";
        if (clientId !== undefined)
            url_ += "clientId=" + encodeURIComponent("" + clientId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWithDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWithDetails(<any>response_);
                } catch (e) {
                    return <Observable<ClientFoodDetailedVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientFoodDetailedVM>><any>_observableThrow(response_);
        }));
    }

    protected processGetWithDetails(response: HttpResponseBase): Observable<ClientFoodDetailedVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientFoodDetailedVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientFoodDetailedVM>(<any>null);
    }

    get2(category: string | null, key: string | null | undefined): Observable<FoodBasicVM> {
        let url_ = this.baseUrl + "/api/ClientFood/{category}?";
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined.");
        url_ = url_.replace("{category}", encodeURIComponent("" + category)); 
        if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<FoodBasicVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<FoodBasicVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FoodBasicVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FoodBasicVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FoodBasicVM>(<any>null);
    }

    update2(type: string | null, command: UpdateClientStatus): Observable<ResponseModelGuid> {
        let url_ = this.baseUrl + "/api/ClientFood/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate2(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModelGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModelGuid>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate2(response: HttpResponseBase): Observable<ResponseModelGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModelGuid>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ClientFood/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getClientReport(clientId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ClientFood/report/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientReport(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IClientRegistrationClient {
    get(): Observable<ClientRegistrationsVM>;
    create(command: CreateClientRegistrationCommand): Observable<string>;
    get2(id: string): Observable<ClientRegistrationsByIdVM>;
    update(id: number, command: UpdateClientRegistrationCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ClientRegistrationClient implements IClientRegistrationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<ClientRegistrationsVM> {
        let url_ = this.baseUrl + "/api/ClientRegistration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ClientRegistrationsVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientRegistrationsVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientRegistrationsVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientRegistrationsVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientRegistrationsVM>(<any>null);
    }

    create(command: CreateClientRegistrationCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/ClientRegistration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    get2(id: string): Observable<ClientRegistrationsByIdVM> {
        let url_ = this.baseUrl + "/api/ClientRegistration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<ClientRegistrationsByIdVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientRegistrationsByIdVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<ClientRegistrationsByIdVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientRegistrationsByIdVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientRegistrationsByIdVM>(<any>null);
    }

    update(id: number, command: UpdateClientRegistrationCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ClientRegistration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ClientRegistration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IFileUploadClient {
    upload(file1: FileParameter | null | undefined): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class FileUploadClient implements IFileUploadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    upload(file1: FileParameter | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/FileUpload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file1 !== null && file1 !== undefined)
            content_.append("file1", file1.data, file1.fileName ? file1.fileName : "file1");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export interface IFoodClient {
    get(foodName: string | null | undefined, id: number | undefined): Observable<FoodVM>;
    create(command: CreateFoodCommand): Observable<ResponseModel>;
    get2(id: number): Observable<FoodByIdVM>;
    update(id: number, command: UpdateFoodCommand): Observable<ResponseModel>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class FoodClient implements IFoodClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(foodName: string | null | undefined, id: number | undefined): Observable<FoodVM> {
        let url_ = this.baseUrl + "/api/Food?";
        if (foodName !== undefined)
            url_ += "foodName=" + encodeURIComponent("" + foodName) + "&"; 
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FoodVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<FoodVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FoodVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FoodVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FoodVM>(<any>null);
    }

    create(command: CreateFoodCommand): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/Food";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    get2(id: number): Observable<FoodByIdVM> {
        let url_ = this.baseUrl + "/api/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<FoodByIdVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<FoodByIdVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FoodByIdVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FoodByIdVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FoodByIdVM>(<any>null);
    }

    update(id: number, command: UpdateFoodCommand): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Food/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IFoodGroupClient {
    get(): Observable<FoodGroupVM>;
    create(command: CreateFoodGroupCommand): Observable<ResponseModel>;
    get2(id: number): Observable<FoodGroupByIdVM>;
    update(id: number, command: UpdateFoodGroupCommand): Observable<ResponseModel>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class FoodGroupClient implements IFoodGroupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<FoodGroupVM> {
        let url_ = this.baseUrl + "/api/FoodGroup";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FoodGroupVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<FoodGroupVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FoodGroupVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FoodGroupVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FoodGroupVM>(<any>null);
    }

    create(command: CreateFoodGroupCommand): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/FoodGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    get2(id: number): Observable<FoodGroupByIdVM> {
        let url_ = this.baseUrl + "/api/FoodGroup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<FoodGroupByIdVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<FoodGroupByIdVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FoodGroupByIdVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FoodGroupByIdVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FoodGroupByIdVM>(<any>null);
    }

    update(id: number, command: UpdateFoodGroupCommand): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/FoodGroup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FoodGroup/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IInvoiceClient {
    getInvoices(businessId: string): Observable<InvoiceListVM>;
}

@Injectable({
    providedIn: 'root'
})
export class InvoiceClient implements IInvoiceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getInvoices(businessId: string): Observable<InvoiceListVM> {
        let url_ = this.baseUrl + "/api/Invoice/{businessId}";
        if (businessId === undefined || businessId === null)
            throw new Error("The parameter 'businessId' must be defined.");
        url_ = url_.replace("{businessId}", encodeURIComponent("" + businessId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoices(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceListVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceListVM>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoices(response: HttpResponseBase): Observable<InvoiceListVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceListVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListVM>(<any>null);
    }
}

export interface ILoginClient {
    logIn(userId: string | null | undefined, password: string | null | undefined, isRemember: boolean | undefined): Observable<UserToken>;
    forgotPassword(userId: string | null | undefined): Observable<ResponseModel>;
    resetPassword(userId: string | null | undefined, newPassword: string | null | undefined, eventId: string | null | undefined): Observable<ResponseModel>;
    updatePassword(userId: string | null | undefined, oldPassword: string | null | undefined, newPassword: string | null | undefined): Observable<ResponseModel>;
}

@Injectable({
    providedIn: 'root'
})
export class LoginClient implements ILoginClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    logIn(userId: string | null | undefined, password: string | null | undefined, isRemember: boolean | undefined): Observable<UserToken> {
        let url_ = this.baseUrl + "/api/Login?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        if (isRemember === null)
            throw new Error("The parameter 'isRemember' cannot be null.");
        else if (isRemember !== undefined)
            url_ += "isRemember=" + encodeURIComponent("" + isRemember) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogIn(<any>response_);
                } catch (e) {
                    return <Observable<UserToken>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserToken>><any>_observableThrow(response_);
        }));
    }

    protected processLogIn(response: HttpResponseBase): Observable<UserToken> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserToken.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserToken>(<any>null);
    }

    forgotPassword(userId: string | null | undefined): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/Login/ForgotPassword?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    resetPassword(userId: string | null | undefined, newPassword: string | null | undefined, eventId: string | null | undefined): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/Login/ResetPassword?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (newPassword !== undefined)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&"; 
        if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    updatePassword(userId: string | null | undefined, oldPassword: string | null | undefined, newPassword: string | null | undefined): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/Login/UpdatePassword?";
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (oldPassword !== undefined)
            url_ += "oldPassword=" + encodeURIComponent("" + oldPassword) + "&"; 
        if (newPassword !== undefined)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePassword(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePassword(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }
}

export interface INutrientClient {
    get(): Observable<NutrientsVM>;
    create(command: CreateNutrientCommand): Observable<ResponseModel>;
    get2(id: number): Observable<NutrientsByIdVM>;
    update(id: number, command: UpdateNutrientCommand): Observable<ResponseModel>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class NutrientClient implements INutrientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<NutrientsVM> {
        let url_ = this.baseUrl + "/api/Nutrient";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<NutrientsVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<NutrientsVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<NutrientsVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NutrientsVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NutrientsVM>(<any>null);
    }

    create(command: CreateNutrientCommand): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/Nutrient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    get2(id: number): Observable<NutrientsByIdVM> {
        let url_ = this.baseUrl + "/api/Nutrient/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<NutrientsByIdVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<NutrientsByIdVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<NutrientsByIdVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NutrientsByIdVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NutrientsByIdVM>(<any>null);
    }

    update(id: number, command: UpdateNutrientCommand): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/Nutrient/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Nutrient/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IPayementsClient {
    payment(createPaymentCommand: CreatePaymentCommand): Observable<ResponseModel>;
}

@Injectable({
    providedIn: 'root'
})
export class PayementsClient implements IPayementsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    payment(createPaymentCommand: CreatePaymentCommand): Observable<ResponseModel> {
        let url_ = this.baseUrl + "/api/Payements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createPaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayment(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processPayment(response: HttpResponseBase): Observable<ResponseModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModel>(<any>null);
    }
}

export interface IPlanClient {
    get(): Observable<PlanVM>;
}

@Injectable({
    providedIn: 'root'
})
export class PlanClient implements IPlanClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<PlanVM> {
        let url_ = this.baseUrl + "/api/Plan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PlanVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<PlanVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PlanVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlanVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PlanVM>(<any>null);
    }
}

export interface IRegistrationClient {
    get(): Observable<RegistrationVM>;
    create(command: CreateRegistrationCommand): Observable<ResponseModelGuid>;
    verifiedEmail(updateRegistrationVerifiedCommand: UpdateRegistrationVerifiedCommand): Observable<ResponseModelGuid>;
    get2(type: string | null, id: string | undefined, userId: string | null | undefined): Observable<RegistrationByIdVM>;
    sendInvite(id: string): Observable<ResponseModelGuid>;
    update(id: string, command: UpdateRegistrationCommand): Observable<ResponseModelGuid>;
    delete(id: string): Observable<FileResponse>;
    sendReport(id: string): Observable<ResponseModelGuid>;
}

@Injectable({
    providedIn: 'root'
})
export class RegistrationClient implements IRegistrationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<RegistrationVM> {
        let url_ = this.baseUrl + "/api/Registration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RegistrationVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegistrationVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RegistrationVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistrationVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistrationVM>(<any>null);
    }

    create(command: CreateRegistrationCommand): Observable<ResponseModelGuid> {
        let url_ = this.baseUrl + "/api/Registration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModelGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModelGuid>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseModelGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModelGuid>(<any>null);
    }

    verifiedEmail(updateRegistrationVerifiedCommand: UpdateRegistrationVerifiedCommand): Observable<ResponseModelGuid> {
        let url_ = this.baseUrl + "/api/Registration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateRegistrationVerifiedCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifiedEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifiedEmail(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModelGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModelGuid>><any>_observableThrow(response_);
        }));
    }

    protected processVerifiedEmail(response: HttpResponseBase): Observable<ResponseModelGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModelGuid>(<any>null);
    }

    get2(type: string | null, id: string | undefined, userId: string | null | undefined): Observable<RegistrationByIdVM> {
        let url_ = this.baseUrl + "/api/Registration/{type}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<RegistrationByIdVM>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegistrationByIdVM>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<RegistrationByIdVM> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistrationByIdVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegistrationByIdVM>(<any>null);
    }

    sendInvite(id: string): Observable<ResponseModelGuid> {
        let url_ = this.baseUrl + "/api/Registration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendInvite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendInvite(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModelGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModelGuid>><any>_observableThrow(response_);
        }));
    }

    protected processSendInvite(response: HttpResponseBase): Observable<ResponseModelGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModelGuid>(<any>null);
    }

    update(id: string, command: UpdateRegistrationCommand): Observable<ResponseModelGuid> {
        let url_ = this.baseUrl + "/api/Registration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModelGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModelGuid>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModelGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModelGuid>(<any>null);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Registration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    sendReport(id: string): Observable<ResponseModelGuid> {
        let url_ = this.baseUrl + "/api/Registration/SendReport/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendReport(<any>response_);
                } catch (e) {
                    return <Observable<ResponseModelGuid>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseModelGuid>><any>_observableThrow(response_);
        }));
    }

    protected processSendReport(response: HttpResponseBase): Observable<ResponseModelGuid> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelGuid.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseModelGuid>(<any>null);
    }
}

export interface IReportClient {
    getClientReportHtml(clientId: string): Observable<FileResponse>;
    getClientReport(clientId: string): Observable<FileResponse>;
    downloadClientReport(clientId: string): Observable<FileResponse>;
    downloadClientReportXls(clientId: string): Observable<FileResponse>;
    getClientInvoiceHtml(invoiceId: string): Observable<FileResponse>;
    getClientInvoicePdf(invoiceId: string): Observable<FileResponse>;
    downloadInvoice(invoiceId: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReportClient implements IReportClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getClientReportHtml(clientId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/report/{clientId}";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientReportHtml(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientReportHtml(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientReportHtml(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getClientReport(clientId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/report/{clientId}/pdf";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientReport(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    downloadClientReport(clientId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/report/{clientId}/download";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadClientReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadClientReport(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadClientReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    downloadClientReportXls(clientId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/report/{clientId}/excel";
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadClientReportXls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadClientReportXls(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadClientReportXls(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getClientInvoiceHtml(invoiceId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/invoice/{invoiceId}";
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientInvoiceHtml(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientInvoiceHtml(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientInvoiceHtml(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getClientInvoicePdf(invoiceId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/invoice/{invoiceId}/pdf";
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientInvoicePdf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientInvoicePdf(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetClientInvoicePdf(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    downloadInvoice(invoiceId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/invoice/{invoiceId}/download";
        if (invoiceId === undefined || invoiceId === null)
            throw new Error("The parameter 'invoiceId' must be defined.");
        url_ = url_.replace("{invoiceId}", encodeURIComponent("" + invoiceId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",			
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadInvoice(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadInvoice(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export class CategoryVM implements ICategoryVM {
    lists?: CategoryDTO[] | undefined;

    constructor(data?: ICategoryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(CategoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryVM {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICategoryVM {
    lists?: CategoryDTO[] | undefined;
}

export class CategoryDTO implements ICategoryDTO {
    id?: number;
    name?: string | undefined;
    sortOrder?: number;

    constructor(data?: ICategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): CategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        return data; 
    }
}

export interface ICategoryDTO {
    id?: number;
    name?: string | undefined;
    sortOrder?: number;
}

export class ClientVM implements IClientVM {
    lists?: ClientDTO[] | undefined;

    constructor(data?: IClientVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ClientDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientVM {
        data = typeof data === 'object' ? data : {};
        let result = new ClientVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IClientVM {
    lists?: ClientDTO[] | undefined;
}

export class ClientDTO implements IClientDTO {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
    status?: string | undefined;
    registration?: Registration | undefined;
    created?: Date;
    isSendInvite?: boolean;
    units?: UnitOfMeasurement;
    maxDays?: number;
    height?: number;
    weight?: number;
    clientGUID?: string | undefined;
    age?: number;
    gender?: Gender | undefined;
    activityLevel?: number | undefined;
    intensityLevel?: number | undefined;
    bmi?: number | undefined;
    bmr?: number | undefined;
    tdee?: number | undefined;

    constructor(data?: IClientDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.status = _data["status"];
            this.registration = _data["registration"] ? Registration.fromJS(_data["registration"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isSendInvite = _data["isSendInvite"];
            this.units = _data["units"];
            this.maxDays = _data["maxDays"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.clientGUID = _data["clientGUID"];
            this.age = _data["age"];
            this.gender = _data["gender"];
            this.activityLevel = _data["activityLevel"];
            this.intensityLevel = _data["intensityLevel"];
            this.bmi = _data["bmi"];
            this.bmr = _data["bmr"];
            this.tdee = _data["tdee"];
        }
    }

    static fromJS(data: any): ClientDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["status"] = this.status;
        data["registration"] = this.registration ? this.registration.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isSendInvite"] = this.isSendInvite;
        data["units"] = this.units;
        data["maxDays"] = this.maxDays;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["clientGUID"] = this.clientGUID;
        data["age"] = this.age;
        data["gender"] = this.gender;
        data["activityLevel"] = this.activityLevel;
        data["intensityLevel"] = this.intensityLevel;
        data["bmi"] = this.bmi;
        data["bmr"] = this.bmr;
        data["tdee"] = this.tdee;
        return data; 
    }
}

export interface IClientDTO {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
    status?: string | undefined;
    registration?: Registration | undefined;
    created?: Date;
    isSendInvite?: boolean;
    units?: UnitOfMeasurement;
    maxDays?: number;
    height?: number;
    weight?: number;
    clientGUID?: string | undefined;
    age?: number;
    gender?: Gender | undefined;
    activityLevel?: number | undefined;
    intensityLevel?: number | undefined;
    bmi?: number | undefined;
    bmr?: number | undefined;
    tdee?: number | undefined;
}

export abstract class AuditableEntity implements IAuditableEntity {
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAuditableEntity {
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
}

export class Registration extends AuditableEntity implements IRegistration {
    id?: string;
    plan?: Plan | undefined;
    userId?: string | undefined;
    companyName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    planExpiryDate?: Date;
    isVerified?: boolean;
    websiteUrl?: string | undefined;
    qualification?: string | undefined;
    photoPath?: string | undefined;
    balance?: number;

    constructor(data?: IRegistration) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.plan = _data["plan"] ? Plan.fromJS(_data["plan"]) : <any>undefined;
            this.userId = _data["userId"];
            this.companyName = _data["companyName"];
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.planExpiryDate = _data["planExpiryDate"] ? new Date(_data["planExpiryDate"].toString()) : <any>undefined;
            this.isVerified = _data["isVerified"];
            this.websiteUrl = _data["websiteUrl"];
            this.qualification = _data["qualification"];
            this.photoPath = _data["photoPath"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): Registration {
        data = typeof data === 'object' ? data : {};
        let result = new Registration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["companyName"] = this.companyName;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["planExpiryDate"] = this.planExpiryDate ? this.planExpiryDate.toISOString() : <any>undefined;
        data["isVerified"] = this.isVerified;
        data["websiteUrl"] = this.websiteUrl;
        data["qualification"] = this.qualification;
        data["photoPath"] = this.photoPath;
        data["balance"] = this.balance;
        super.toJSON(data);
        return data; 
    }
}

export interface IRegistration extends IAuditableEntity {
    id?: string;
    plan?: Plan | undefined;
    userId?: string | undefined;
    companyName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    planExpiryDate?: Date;
    isVerified?: boolean;
    websiteUrl?: string | undefined;
    qualification?: string | undefined;
    photoPath?: string | undefined;
    balance?: number;
}

export class Plan extends AuditableEntity implements IPlan {
    id?: number;
    description?: string | undefined;
    maxCustomers?: number;
    active?: boolean;
    price?: number;
    interval?: string | undefined;

    constructor(data?: IPlan) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.maxCustomers = _data["maxCustomers"];
            this.active = _data["active"];
            this.price = _data["price"];
            this.interval = _data["interval"];
        }
    }

    static fromJS(data: any): Plan {
        data = typeof data === 'object' ? data : {};
        let result = new Plan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["maxCustomers"] = this.maxCustomers;
        data["active"] = this.active;
        data["price"] = this.price;
        data["interval"] = this.interval;
        super.toJSON(data);
        return data; 
    }
}

export interface IPlan extends IAuditableEntity {
    id?: number;
    description?: string | undefined;
    maxCustomers?: number;
    active?: boolean;
    price?: number;
    interval?: string | undefined;
}

export enum UnitOfMeasurement {
    Metric = 0,
    Imperial = 1,
}

export enum Gender {
    Male = 0,
    Female = 1,
}

export class ClientByIdVM implements IClientByIdVM {
    data?: ClientDTO | undefined;

    constructor(data?: IClientByIdVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ClientDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientByIdVM {
        data = typeof data === 'object' ? data : {};
        let result = new ClientByIdVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IClientByIdVM {
    data?: ClientDTO | undefined;
}

export class ResponseModelGuid implements IResponseModelGuid {
    succeeded?: boolean;
    errors?: string | undefined;
    data?: string;

    constructor(data?: IResponseModelGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.errors = _data["errors"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ResponseModelGuid {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["errors"] = this.errors;
        data["data"] = this.data;
        return data; 
    }
}

export interface IResponseModelGuid {
    succeeded?: boolean;
    errors?: string | undefined;
    data?: string;
}

export class CreateClientCommand implements ICreateClientCommand {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
    status?: string | undefined;
    businessId?: string;
    maxDays?: number;
    unitOfMeasure?: string | undefined;
    height?: number;
    weight?: number;
    age?: number;
    gender?: string | undefined;

    constructor(data?: ICreateClientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.status = _data["status"];
            this.businessId = _data["businessId"];
            this.maxDays = _data["maxDays"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.age = _data["age"];
            this.gender = _data["gender"];
        }
    }

    static fromJS(data: any): CreateClientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["status"] = this.status;
        data["businessId"] = this.businessId;
        data["maxDays"] = this.maxDays;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["age"] = this.age;
        data["gender"] = this.gender;
        return data; 
    }
}

export interface ICreateClientCommand {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
    status?: string | undefined;
    businessId?: string;
    maxDays?: number;
    unitOfMeasure?: string | undefined;
    height?: number;
    weight?: number;
    age?: number;
    gender?: string | undefined;
}

export class UpdateClientCommand implements IUpdateClientCommand {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
    status?: string | undefined;
    businessId?: string;
    isSendInvite?: boolean;
    maxDays?: number;
    height?: number;
    weight?: number;
    age?: number;
    gender?: string | undefined;

    constructor(data?: IUpdateClientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.emailAddress = _data["emailAddress"];
            this.status = _data["status"];
            this.businessId = _data["businessId"];
            this.isSendInvite = _data["isSendInvite"];
            this.maxDays = _data["maxDays"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.age = _data["age"];
            this.gender = _data["gender"];
        }
    }

    static fromJS(data: any): UpdateClientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["emailAddress"] = this.emailAddress;
        data["status"] = this.status;
        data["businessId"] = this.businessId;
        data["isSendInvite"] = this.isSendInvite;
        data["maxDays"] = this.maxDays;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["age"] = this.age;
        data["gender"] = this.gender;
        return data; 
    }
}

export interface IUpdateClientCommand {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    emailAddress?: string | undefined;
    status?: string | undefined;
    businessId?: string;
    isSendInvite?: boolean;
    maxDays?: number;
    height?: number;
    weight?: number;
    age?: number;
    gender?: string | undefined;
}

export class ResponseModel implements IResponseModel {
    succeeded?: boolean;
    errors?: string | undefined;
    data?: number;

    constructor(data?: IResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.errors = _data["errors"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): ResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["errors"] = this.errors;
        data["data"] = this.data;
        return data; 
    }
}

export interface IResponseModel {
    succeeded?: boolean;
    errors?: string | undefined;
    data?: number;
}

export class UpdateClientFoodCommand implements IUpdateClientFoodCommand {
    clientFood?: ClientFood[] | undefined;

    constructor(data?: IUpdateClientFoodCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clientFood"])) {
                this.clientFood = [] as any;
                for (let item of _data["clientFood"])
                    this.clientFood!.push(ClientFood.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateClientFoodCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientFoodCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clientFood)) {
            data["clientFood"] = [];
            for (let item of this.clientFood)
                data["clientFood"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateClientFoodCommand {
    clientFood?: ClientFood[] | undefined;
}

export class ClientFood implements IClientFood {
    id?: number;
    clientId?: string | undefined;
    food?: Food | undefined;
    day?: number;
    actualIntake?: number;
    meal?: Meal;

    constructor(data?: IClientFood) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.food = _data["food"] ? Food.fromJS(_data["food"]) : <any>undefined;
            this.day = _data["day"];
            this.actualIntake = _data["actualIntake"];
            this.meal = _data["meal"];
        }
    }

    static fromJS(data: any): ClientFood {
        data = typeof data === 'object' ? data : {};
        let result = new ClientFood();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["food"] = this.food ? this.food.toJSON() : <any>undefined;
        data["day"] = this.day;
        data["actualIntake"] = this.actualIntake;
        data["meal"] = this.meal;
        return data; 
    }
}

export interface IClientFood {
    id?: number;
    clientId?: string | undefined;
    food?: Food | undefined;
    day?: number;
    actualIntake?: number;
    meal?: Meal;
}

export class Food extends AuditableEntity implements IFood {
    id?: number;
    foodGroup?: FoodGroup | undefined;
    name?: string | undefined;
    servingSuggestion?: string | undefined;
    nutrients?: NutrientValue[] | undefined;
    actualIntake?: number;

    constructor(data?: IFood) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.foodGroup = _data["foodGroup"] ? FoodGroup.fromJS(_data["foodGroup"]) : <any>undefined;
            this.name = _data["name"];
            this.servingSuggestion = _data["servingSuggestion"];
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientValue.fromJS(item));
            }
            this.actualIntake = _data["actualIntake"];
        }
    }

    static fromJS(data: any): Food {
        data = typeof data === 'object' ? data : {};
        let result = new Food();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["foodGroup"] = this.foodGroup ? this.foodGroup.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["servingSuggestion"] = this.servingSuggestion;
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        data["actualIntake"] = this.actualIntake;
        super.toJSON(data);
        return data; 
    }
}

export interface IFood extends IAuditableEntity {
    id?: number;
    foodGroup?: FoodGroup | undefined;
    name?: string | undefined;
    servingSuggestion?: string | undefined;
    nutrients?: NutrientValue[] | undefined;
    actualIntake?: number;
}

export class FoodGroup extends AuditableEntity implements IFoodGroup {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IFoodGroup) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FoodGroup {
        data = typeof data === 'object' ? data : {};
        let result = new FoodGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        super.toJSON(data);
        return data; 
    }
}

export interface IFoodGroup extends IAuditableEntity {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class NutrientValue extends AuditableEntity implements INutrientValue {
    id?: number;
    food?: Food | undefined;
    nutrient?: Nutrient | undefined;
    value?: number;

    constructor(data?: INutrientValue) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.food = _data["food"] ? Food.fromJS(_data["food"]) : <any>undefined;
            this.nutrient = _data["nutrient"] ? Nutrient.fromJS(_data["nutrient"]) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NutrientValue {
        data = typeof data === 'object' ? data : {};
        let result = new NutrientValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["food"] = this.food ? this.food.toJSON() : <any>undefined;
        data["nutrient"] = this.nutrient ? this.nutrient.toJSON() : <any>undefined;
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface INutrientValue extends IAuditableEntity {
    id?: number;
    food?: Food | undefined;
    nutrient?: Nutrient | undefined;
    value?: number;
}

export class Nutrient extends AuditableEntity implements INutrient {
    id?: number;
    name?: string | undefined;
    unit?: string | undefined;
    description?: string | undefined;
    category?: Category | undefined;
    recommendedMin?: number;
    recommendedMax?: number;
    divisor?: number | undefined;
    multiplier?: number | undefined;
    totaliser?: number | undefined;

    constructor(data?: INutrient) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.description = _data["description"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.recommendedMin = _data["recommendedMin"];
            this.recommendedMax = _data["recommendedMax"];
            this.divisor = _data["divisor"];
            this.multiplier = _data["multiplier"];
            this.totaliser = _data["totaliser"];
        }
    }

    static fromJS(data: any): Nutrient {
        data = typeof data === 'object' ? data : {};
        let result = new Nutrient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["description"] = this.description;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["recommendedMin"] = this.recommendedMin;
        data["recommendedMax"] = this.recommendedMax;
        data["divisor"] = this.divisor;
        data["multiplier"] = this.multiplier;
        data["totaliser"] = this.totaliser;
        super.toJSON(data);
        return data; 
    }
}

export interface INutrient extends IAuditableEntity {
    id?: number;
    name?: string | undefined;
    unit?: string | undefined;
    description?: string | undefined;
    category?: Category | undefined;
    recommendedMin?: number;
    recommendedMax?: number;
    divisor?: number | undefined;
    multiplier?: number | undefined;
    totaliser?: number | undefined;
}

export class Category extends AuditableEntity implements ICategory {
    id?: number;
    name?: string | undefined;
    sortOrder?: number;

    constructor(data?: ICategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortOrder"] = this.sortOrder;
        super.toJSON(data);
        return data; 
    }
}

export interface ICategory extends IAuditableEntity {
    id?: number;
    name?: string | undefined;
    sortOrder?: number;
}

export enum Meal {
    Breakfast = 0,
    Lunch = 1,
    Dinner = 2,
    Snack = 3,
}

export class ClientFoodVM implements IClientFoodVM {
    lists?: ClientFoodDTO[] | undefined;

    constructor(data?: IClientFoodVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ClientFoodDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientFoodVM {
        data = typeof data === 'object' ? data : {};
        let result = new ClientFoodVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IClientFoodVM {
    lists?: ClientFoodDTO[] | undefined;
}

export class ClientFoodDTO implements IClientFoodDTO {
    id?: number;
    clientId?: string | undefined;
    foodId?: string | undefined;
    foodName?: string | undefined;
    foodGroupName?: string | undefined;
    day?: number;
    actualIntake?: number;
    meal?: Meal;

    constructor(data?: IClientFoodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.foodId = _data["foodId"];
            this.foodName = _data["foodName"];
            this.foodGroupName = _data["foodGroupName"];
            this.day = _data["day"];
            this.actualIntake = _data["actualIntake"];
            this.meal = _data["meal"];
        }
    }

    static fromJS(data: any): ClientFoodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClientFoodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["foodId"] = this.foodId;
        data["foodName"] = this.foodName;
        data["foodGroupName"] = this.foodGroupName;
        data["day"] = this.day;
        data["actualIntake"] = this.actualIntake;
        data["meal"] = this.meal;
        return data; 
    }
}

export interface IClientFoodDTO {
    id?: number;
    clientId?: string | undefined;
    foodId?: string | undefined;
    foodName?: string | undefined;
    foodGroupName?: string | undefined;
    day?: number;
    actualIntake?: number;
    meal?: Meal;
}

export class ClientFoodDetailedVM implements IClientFoodDetailedVM {
    lists?: ClientFoodWithDetailsDTO[] | undefined;

    constructor(data?: IClientFoodDetailedVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ClientFoodWithDetailsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientFoodDetailedVM {
        data = typeof data === 'object' ? data : {};
        let result = new ClientFoodDetailedVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IClientFoodDetailedVM {
    lists?: ClientFoodWithDetailsDTO[] | undefined;
}

export class ClientFoodWithDetailsDTO implements IClientFoodWithDetailsDTO {
    id?: number;
    clientId?: string | undefined;
    food?: Food | undefined;
    day?: number;
    actualIntake?: number;
    meal?: Meal;

    constructor(data?: IClientFoodWithDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.clientId = _data["clientId"];
            this.food = _data["food"] ? Food.fromJS(_data["food"]) : <any>undefined;
            this.day = _data["day"];
            this.actualIntake = _data["actualIntake"];
            this.meal = _data["meal"];
        }
    }

    static fromJS(data: any): ClientFoodWithDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClientFoodWithDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["clientId"] = this.clientId;
        data["food"] = this.food ? this.food.toJSON() : <any>undefined;
        data["day"] = this.day;
        data["actualIntake"] = this.actualIntake;
        data["meal"] = this.meal;
        return data; 
    }
}

export interface IClientFoodWithDetailsDTO {
    id?: number;
    clientId?: string | undefined;
    food?: Food | undefined;
    day?: number;
    actualIntake?: number;
    meal?: Meal;
}

export class FoodBasicVM implements IFoodBasicVM {
    lists?: FoodBasicDTO[] | undefined;

    constructor(data?: IFoodBasicVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(FoodBasicDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodBasicVM {
        data = typeof data === 'object' ? data : {};
        let result = new FoodBasicVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFoodBasicVM {
    lists?: FoodBasicDTO[] | undefined;
}

export class FoodBasicDTO implements IFoodBasicDTO {
    foodGroup?: FoodGroup | undefined;
    foodId?: string | undefined;
    foodName?: string | undefined;
    foodGroupName?: string | undefined;
    servingSuggestion?: string | undefined;

    constructor(data?: IFoodBasicDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodGroup = _data["foodGroup"] ? FoodGroup.fromJS(_data["foodGroup"]) : <any>undefined;
            this.foodId = _data["foodId"];
            this.foodName = _data["foodName"];
            this.foodGroupName = _data["foodGroupName"];
            this.servingSuggestion = _data["servingSuggestion"];
        }
    }

    static fromJS(data: any): FoodBasicDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FoodBasicDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodGroup"] = this.foodGroup ? this.foodGroup.toJSON() : <any>undefined;
        data["foodId"] = this.foodId;
        data["foodName"] = this.foodName;
        data["foodGroupName"] = this.foodGroupName;
        data["servingSuggestion"] = this.servingSuggestion;
        return data; 
    }
}

export interface IFoodBasicDTO {
    foodGroup?: FoodGroup | undefined;
    foodId?: string | undefined;
    foodName?: string | undefined;
    foodGroupName?: string | undefined;
    servingSuggestion?: string | undefined;
}

export class CreateClientFoodCommand implements ICreateClientFoodCommand {
    clientId?: string | undefined;
    foodList?: ClientFood[] | undefined;
    day?: number;

    constructor(data?: ICreateClientFoodCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            if (Array.isArray(_data["foodList"])) {
                this.foodList = [] as any;
                for (let item of _data["foodList"])
                    this.foodList!.push(ClientFood.fromJS(item));
            }
            this.day = _data["day"];
        }
    }

    static fromJS(data: any): CreateClientFoodCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientFoodCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        if (Array.isArray(this.foodList)) {
            data["foodList"] = [];
            for (let item of this.foodList)
                data["foodList"].push(item.toJSON());
        }
        data["day"] = this.day;
        return data; 
    }
}

export interface ICreateClientFoodCommand {
    clientId?: string | undefined;
    foodList?: ClientFood[] | undefined;
    day?: number;
}

export class UpdateClientByUserId implements IUpdateClientByUserId {
    clientId?: string;
    height?: number;
    weight?: number;
    age?: number;
    gender?: string | undefined;
    units?: string | undefined;
    bmi?: number;
    bmr?: number;
    tdee?: number;
    activityLevel?: number;
    exerciseLevel?: number;

    constructor(data?: IUpdateClientByUserId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.age = _data["age"];
            this.gender = _data["gender"];
            this.units = _data["units"];
            this.bmi = _data["bmi"];
            this.bmr = _data["bmr"];
            this.tdee = _data["tdee"];
            this.activityLevel = _data["activityLevel"];
            this.exerciseLevel = _data["exerciseLevel"];
        }
    }

    static fromJS(data: any): UpdateClientByUserId {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientByUserId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["age"] = this.age;
        data["gender"] = this.gender;
        data["units"] = this.units;
        data["bmi"] = this.bmi;
        data["bmr"] = this.bmr;
        data["tdee"] = this.tdee;
        data["activityLevel"] = this.activityLevel;
        data["exerciseLevel"] = this.exerciseLevel;
        return data; 
    }
}

export interface IUpdateClientByUserId {
    clientId?: string;
    height?: number;
    weight?: number;
    age?: number;
    gender?: string | undefined;
    units?: string | undefined;
    bmi?: number;
    bmr?: number;
    tdee?: number;
    activityLevel?: number;
    exerciseLevel?: number;
}

export class UpdateClientStatus implements IUpdateClientStatus {
    clientId?: string;
    status?: string | undefined;

    constructor(data?: IUpdateClientStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateClientStatus {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateClientStatus {
    clientId?: string;
    status?: string | undefined;
}

export class ClientRegistrationsVM implements IClientRegistrationsVM {
    lists?: ClientRegistrationsDTO[] | undefined;

    constructor(data?: IClientRegistrationsVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(ClientRegistrationsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientRegistrationsVM {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRegistrationsVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IClientRegistrationsVM {
    lists?: ClientRegistrationsDTO[] | undefined;
}

export class ClientRegistrationsDTO implements IClientRegistrationsDTO {
    id?: number;
    businessName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactNumber?: string | undefined;
    contactEmail?: string | undefined;
    planId?: number;
    planExpiryDate?: Date;

    constructor(data?: IClientRegistrationsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessName = _data["businessName"];
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.contactNumber = _data["contactNumber"];
            this.contactEmail = _data["contactEmail"];
            this.planId = _data["planId"];
            this.planExpiryDate = _data["planExpiryDate"] ? new Date(_data["planExpiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientRegistrationsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRegistrationsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessName"] = this.businessName;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["contactNumber"] = this.contactNumber;
        data["contactEmail"] = this.contactEmail;
        data["planId"] = this.planId;
        data["planExpiryDate"] = this.planExpiryDate ? this.planExpiryDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IClientRegistrationsDTO {
    id?: number;
    businessName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactNumber?: string | undefined;
    contactEmail?: string | undefined;
    planId?: number;
    planExpiryDate?: Date;
}

export class ClientRegistrationsByIdVM implements IClientRegistrationsByIdVM {
    data?: ClientRegistrationsDTO | undefined;

    constructor(data?: IClientRegistrationsByIdVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? ClientRegistrationsDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientRegistrationsByIdVM {
        data = typeof data === 'object' ? data : {};
        let result = new ClientRegistrationsByIdVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IClientRegistrationsByIdVM {
    data?: ClientRegistrationsDTO | undefined;
}

export class CreateClientRegistrationCommand implements ICreateClientRegistrationCommand {
    id?: string;
    businessName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactNumber?: string | undefined;
    contactEmail?: string | undefined;
    planId?: number;
    planExpiryDate?: Date;

    constructor(data?: ICreateClientRegistrationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessName = _data["businessName"];
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.contactNumber = _data["contactNumber"];
            this.contactEmail = _data["contactEmail"];
            this.planId = _data["planId"];
            this.planExpiryDate = _data["planExpiryDate"] ? new Date(_data["planExpiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateClientRegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientRegistrationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessName"] = this.businessName;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["contactNumber"] = this.contactNumber;
        data["contactEmail"] = this.contactEmail;
        data["planId"] = this.planId;
        data["planExpiryDate"] = this.planExpiryDate ? this.planExpiryDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateClientRegistrationCommand {
    id?: string;
    businessName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactNumber?: string | undefined;
    contactEmail?: string | undefined;
    planId?: number;
    planExpiryDate?: Date;
}

export class UpdateClientRegistrationCommand implements IUpdateClientRegistrationCommand {
    id?: number;
    businessName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactNumber?: string | undefined;
    contactEmail?: string | undefined;
    planId?: number;
    planExpiryDate?: Date;

    constructor(data?: IUpdateClientRegistrationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessName = _data["businessName"];
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.contactNumber = _data["contactNumber"];
            this.contactEmail = _data["contactEmail"];
            this.planId = _data["planId"];
            this.planExpiryDate = _data["planExpiryDate"] ? new Date(_data["planExpiryDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateClientRegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientRegistrationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessName"] = this.businessName;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["contactNumber"] = this.contactNumber;
        data["contactEmail"] = this.contactEmail;
        data["planId"] = this.planId;
        data["planExpiryDate"] = this.planExpiryDate ? this.planExpiryDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateClientRegistrationCommand {
    id?: number;
    businessName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactNumber?: string | undefined;
    contactEmail?: string | undefined;
    planId?: number;
    planExpiryDate?: Date;
}

export class FoodVM implements IFoodVM {
    lists?: FoodDTO[] | undefined;

    constructor(data?: IFoodVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(FoodDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodVM {
        data = typeof data === 'object' ? data : {};
        let result = new FoodVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFoodVM {
    lists?: FoodDTO[] | undefined;
}

export class FoodDTO implements IFoodDTO {
    foodGroup?: FoodGroup | undefined;
    id?: number;
    name?: string | undefined;
    servingSuggestion?: string | undefined;
    nutrients?: NutrientValue[] | undefined;

    constructor(data?: IFoodDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodGroup = _data["foodGroup"] ? FoodGroup.fromJS(_data["foodGroup"]) : <any>undefined;
            this.id = _data["id"];
            this.name = _data["name"];
            this.servingSuggestion = _data["servingSuggestion"];
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FoodDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodGroup"] = this.foodGroup ? this.foodGroup.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["servingSuggestion"] = this.servingSuggestion;
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFoodDTO {
    foodGroup?: FoodGroup | undefined;
    id?: number;
    name?: string | undefined;
    servingSuggestion?: string | undefined;
    nutrients?: NutrientValue[] | undefined;
}

export class FoodByIdVM implements IFoodByIdVM {
    data?: FoodDTO | undefined;

    constructor(data?: IFoodByIdVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? FoodDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FoodByIdVM {
        data = typeof data === 'object' ? data : {};
        let result = new FoodByIdVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFoodByIdVM {
    data?: FoodDTO | undefined;
}

export class CreateFoodCommand implements ICreateFoodCommand {
    id?: number;
    foodGroupId?: number;
    name?: string | undefined;
    servingSuggestion?: string | undefined;
    nutrients?: NutrientValue[] | undefined;

    constructor(data?: ICreateFoodCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.foodGroupId = _data["foodGroupId"];
            this.name = _data["name"];
            this.servingSuggestion = _data["servingSuggestion"];
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateFoodCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFoodCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["foodGroupId"] = this.foodGroupId;
        data["name"] = this.name;
        data["servingSuggestion"] = this.servingSuggestion;
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateFoodCommand {
    id?: number;
    foodGroupId?: number;
    name?: string | undefined;
    servingSuggestion?: string | undefined;
    nutrients?: NutrientValue[] | undefined;
}

export class UpdateFoodCommand implements IUpdateFoodCommand {
    foodGroupId?: number;
    id?: number;
    name?: string | undefined;
    servingSuggestion?: string | undefined;
    nutrients?: NutrientValue[] | undefined;

    constructor(data?: IUpdateFoodCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.foodGroupId = _data["foodGroupId"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.servingSuggestion = _data["servingSuggestion"];
            if (Array.isArray(_data["nutrients"])) {
                this.nutrients = [] as any;
                for (let item of _data["nutrients"])
                    this.nutrients!.push(NutrientValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateFoodCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFoodCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["foodGroupId"] = this.foodGroupId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["servingSuggestion"] = this.servingSuggestion;
        if (Array.isArray(this.nutrients)) {
            data["nutrients"] = [];
            for (let item of this.nutrients)
                data["nutrients"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateFoodCommand {
    foodGroupId?: number;
    id?: number;
    name?: string | undefined;
    servingSuggestion?: string | undefined;
    nutrients?: NutrientValue[] | undefined;
}

export class FoodGroupVM implements IFoodGroupVM {
    lists?: FoodGroupDTO[] | undefined;

    constructor(data?: IFoodGroupVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(FoodGroupDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoodGroupVM {
        data = typeof data === 'object' ? data : {};
        let result = new FoodGroupVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFoodGroupVM {
    lists?: FoodGroupDTO[] | undefined;
}

export class FoodGroupDTO implements IFoodGroupDTO {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IFoodGroupDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FoodGroupDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FoodGroupDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IFoodGroupDTO {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class FoodGroupByIdVM implements IFoodGroupByIdVM {
    data?: FoodGroupDTO | undefined;

    constructor(data?: IFoodGroupByIdVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? FoodGroupDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FoodGroupByIdVM {
        data = typeof data === 'object' ? data : {};
        let result = new FoodGroupByIdVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFoodGroupByIdVM {
    data?: FoodGroupDTO | undefined;
}

export class CreateFoodGroupCommand implements ICreateFoodGroupCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateFoodGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateFoodGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFoodGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface ICreateFoodGroupCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class UpdateFoodGroupCommand implements IUpdateFoodGroupCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateFoodGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateFoodGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFoodGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        return data; 
    }
}

export interface IUpdateFoodGroupCommand {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
}

export class InvoiceListVM implements IInvoiceListVM {
    lists?: InvoiceVM[] | undefined;

    constructor(data?: IInvoiceListVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(InvoiceVM.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoiceListVM {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceListVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInvoiceListVM {
    lists?: InvoiceVM[] | undefined;
}

export class InvoiceVM implements IInvoiceVM {
    id?: string;
    businessId?: string;
    business?: RegistrationDTO | undefined;
    planName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    amount?: number;
    cardType?: string | undefined;
    billedTo?: string | undefined;

    constructor(data?: IInvoiceVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.businessId = _data["businessId"];
            this.business = _data["business"] ? RegistrationDTO.fromJS(_data["business"]) : <any>undefined;
            this.planName = _data["planName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.cardType = _data["cardType"];
            this.billedTo = _data["billedTo"];
        }
    }

    static fromJS(data: any): InvoiceVM {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["businessId"] = this.businessId;
        data["business"] = this.business ? this.business.toJSON() : <any>undefined;
        data["planName"] = this.planName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["cardType"] = this.cardType;
        data["billedTo"] = this.billedTo;
        return data; 
    }
}

export interface IInvoiceVM {
    id?: string;
    businessId?: string;
    business?: RegistrationDTO | undefined;
    planName?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    amount?: number;
    cardType?: string | undefined;
    billedTo?: string | undefined;
}

export class RegistrationDTO implements IRegistrationDTO {
    plan?: Plan | undefined;
    id?: string;
    companyName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    planExpiryDate?: Date;
    userId?: string | undefined;
    isVerified?: boolean;
    websiteUrl?: string | undefined;
    qualification?: string | undefined;
    photoPath?: string | undefined;
    balance?: number;

    constructor(data?: IRegistrationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.plan = _data["plan"] ? Plan.fromJS(_data["plan"]) : <any>undefined;
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.planExpiryDate = _data["planExpiryDate"] ? new Date(_data["planExpiryDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.isVerified = _data["isVerified"];
            this.websiteUrl = _data["websiteUrl"];
            this.qualification = _data["qualification"];
            this.photoPath = _data["photoPath"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): RegistrationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["planExpiryDate"] = this.planExpiryDate ? this.planExpiryDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["isVerified"] = this.isVerified;
        data["websiteUrl"] = this.websiteUrl;
        data["qualification"] = this.qualification;
        data["photoPath"] = this.photoPath;
        data["balance"] = this.balance;
        return data; 
    }
}

export interface IRegistrationDTO {
    plan?: Plan | undefined;
    id?: string;
    companyName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    planExpiryDate?: Date;
    userId?: string | undefined;
    isVerified?: boolean;
    websiteUrl?: string | undefined;
    qualification?: string | undefined;
    photoPath?: string | undefined;
    balance?: number;
}

export class UserToken implements IUserToken {
    userId?: string | undefined;
    userType?: string | undefined;
    token?: string | undefined;
    status?: string | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userType = _data["userType"];
            this.token = _data["token"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userType"] = this.userType;
        data["token"] = this.token;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUserToken {
    userId?: string | undefined;
    userType?: string | undefined;
    token?: string | undefined;
    status?: string | undefined;
}

export class NutrientsVM implements INutrientsVM {
    lists?: NutrientsDTO[] | undefined;

    constructor(data?: INutrientsVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(NutrientsDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NutrientsVM {
        data = typeof data === 'object' ? data : {};
        let result = new NutrientsVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INutrientsVM {
    lists?: NutrientsDTO[] | undefined;
}

export class NutrientsDTO implements INutrientsDTO {
    id?: number;
    name?: string | undefined;
    unit?: string | undefined;
    description?: string | undefined;
    category?: Category | undefined;
    recommendedMin?: number;
    recommendedMax?: number;
    divisor?: number | undefined;
    multiplier?: number | undefined;
    totaliser?: number | undefined;

    constructor(data?: INutrientsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.description = _data["description"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
            this.recommendedMin = _data["recommendedMin"];
            this.recommendedMax = _data["recommendedMax"];
            this.divisor = _data["divisor"];
            this.multiplier = _data["multiplier"];
            this.totaliser = _data["totaliser"];
        }
    }

    static fromJS(data: any): NutrientsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NutrientsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["description"] = this.description;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["recommendedMin"] = this.recommendedMin;
        data["recommendedMax"] = this.recommendedMax;
        data["divisor"] = this.divisor;
        data["multiplier"] = this.multiplier;
        data["totaliser"] = this.totaliser;
        return data; 
    }
}

export interface INutrientsDTO {
    id?: number;
    name?: string | undefined;
    unit?: string | undefined;
    description?: string | undefined;
    category?: Category | undefined;
    recommendedMin?: number;
    recommendedMax?: number;
    divisor?: number | undefined;
    multiplier?: number | undefined;
    totaliser?: number | undefined;
}

export class NutrientsByIdVM implements INutrientsByIdVM {
    data?: NutrientsDTO | undefined;

    constructor(data?: INutrientsByIdVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? NutrientsDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NutrientsByIdVM {
        data = typeof data === 'object' ? data : {};
        let result = new NutrientsByIdVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface INutrientsByIdVM {
    data?: NutrientsDTO | undefined;
}

export class CreateNutrientCommand implements ICreateNutrientCommand {
    id?: number;
    name?: string | undefined;
    unit?: string | undefined;
    description?: string | undefined;
    categoryId?: number;
    recommendedMin?: number;
    recommendedMax?: number;
    divisor?: number | undefined;
    multiplier?: number | undefined;

    constructor(data?: ICreateNutrientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.description = _data["description"];
            this.categoryId = _data["categoryId"];
            this.recommendedMin = _data["recommendedMin"];
            this.recommendedMax = _data["recommendedMax"];
            this.divisor = _data["divisor"];
            this.multiplier = _data["multiplier"];
        }
    }

    static fromJS(data: any): CreateNutrientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNutrientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["description"] = this.description;
        data["categoryId"] = this.categoryId;
        data["recommendedMin"] = this.recommendedMin;
        data["recommendedMax"] = this.recommendedMax;
        data["divisor"] = this.divisor;
        data["multiplier"] = this.multiplier;
        return data; 
    }
}

export interface ICreateNutrientCommand {
    id?: number;
    name?: string | undefined;
    unit?: string | undefined;
    description?: string | undefined;
    categoryId?: number;
    recommendedMin?: number;
    recommendedMax?: number;
    divisor?: number | undefined;
    multiplier?: number | undefined;
}

export class UpdateNutrientCommand implements IUpdateNutrientCommand {
    id?: number;
    name?: string | undefined;
    unit?: string | undefined;
    description?: string | undefined;
    categoryId?: number;
    recommendedMin?: number;
    recommendedMax?: number;
    divisor?: number | undefined;
    multiplier?: number | undefined;

    constructor(data?: IUpdateNutrientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.unit = _data["unit"];
            this.description = _data["description"];
            this.categoryId = _data["categoryId"];
            this.recommendedMin = _data["recommendedMin"];
            this.recommendedMax = _data["recommendedMax"];
            this.divisor = _data["divisor"];
            this.multiplier = _data["multiplier"];
        }
    }

    static fromJS(data: any): UpdateNutrientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNutrientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["unit"] = this.unit;
        data["description"] = this.description;
        data["categoryId"] = this.categoryId;
        data["recommendedMin"] = this.recommendedMin;
        data["recommendedMax"] = this.recommendedMax;
        data["divisor"] = this.divisor;
        data["multiplier"] = this.multiplier;
        return data; 
    }
}

export interface IUpdateNutrientCommand {
    id?: number;
    name?: string | undefined;
    unit?: string | undefined;
    description?: string | undefined;
    categoryId?: number;
    recommendedMin?: number;
    recommendedMax?: number;
    divisor?: number | undefined;
    multiplier?: number | undefined;
}

export class CreatePaymentCommand implements ICreatePaymentCommand {
    email?: string | undefined;
    dateCreated?: Date;
    cardNumber?: string | undefined;
    displayNumber?: string | undefined;
    expiryMonth?: string | undefined;
    expiryYear?: string | undefined;
    cvv?: string | undefined;
    name?: string | undefined;
    address1?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    description?: string | undefined;
    currency?: string | undefined;
    amount?: number;
    planId?: number;
    planExpiryDate?: Date;
    billedTo?: string | undefined;

    constructor(data?: ICreatePaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.cardNumber = _data["cardNumber"];
            this.displayNumber = _data["displayNumber"];
            this.expiryMonth = _data["expiryMonth"];
            this.expiryYear = _data["expiryYear"];
            this.cvv = _data["cvv"];
            this.name = _data["name"];
            this.address1 = _data["address1"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.description = _data["description"];
            this.currency = _data["currency"];
            this.amount = _data["amount"];
            this.planId = _data["planId"];
            this.planExpiryDate = _data["planExpiryDate"] ? new Date(_data["planExpiryDate"].toString()) : <any>undefined;
            this.billedTo = _data["billedTo"];
        }
    }

    static fromJS(data: any): CreatePaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["cardNumber"] = this.cardNumber;
        data["displayNumber"] = this.displayNumber;
        data["expiryMonth"] = this.expiryMonth;
        data["expiryYear"] = this.expiryYear;
        data["cvv"] = this.cvv;
        data["name"] = this.name;
        data["address1"] = this.address1;
        data["city"] = this.city;
        data["country"] = this.country;
        data["description"] = this.description;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        data["planId"] = this.planId;
        data["planExpiryDate"] = this.planExpiryDate ? this.planExpiryDate.toISOString() : <any>undefined;
        data["billedTo"] = this.billedTo;
        return data; 
    }
}

export interface ICreatePaymentCommand {
    email?: string | undefined;
    dateCreated?: Date;
    cardNumber?: string | undefined;
    displayNumber?: string | undefined;
    expiryMonth?: string | undefined;
    expiryYear?: string | undefined;
    cvv?: string | undefined;
    name?: string | undefined;
    address1?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    description?: string | undefined;
    currency?: string | undefined;
    amount?: number;
    planId?: number;
    planExpiryDate?: Date;
    billedTo?: string | undefined;
}

export class PlanVM implements IPlanVM {
    lists?: PlanDTO[] | undefined;

    constructor(data?: IPlanVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(PlanDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlanVM {
        data = typeof data === 'object' ? data : {};
        let result = new PlanVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPlanVM {
    lists?: PlanDTO[] | undefined;
}

export class PlanDTO implements IPlanDTO {
    id?: number;
    description?: string | undefined;
    maxEmployees?: number;
    active?: boolean;
    price?: number;
    interval?: string | undefined;

    constructor(data?: IPlanDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.maxEmployees = _data["maxEmployees"];
            this.active = _data["active"];
            this.price = _data["price"];
            this.interval = _data["interval"];
        }
    }

    static fromJS(data: any): PlanDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PlanDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["maxEmployees"] = this.maxEmployees;
        data["active"] = this.active;
        data["price"] = this.price;
        data["interval"] = this.interval;
        return data; 
    }
}

export interface IPlanDTO {
    id?: number;
    description?: string | undefined;
    maxEmployees?: number;
    active?: boolean;
    price?: number;
    interval?: string | undefined;
}

export class RegistrationVM implements IRegistrationVM {
    lists?: RegistrationDTO[] | undefined;

    constructor(data?: IRegistrationVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(RegistrationDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RegistrationVM {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRegistrationVM {
    lists?: RegistrationDTO[] | undefined;
}

export class RegistrationByIdVM implements IRegistrationByIdVM {
    data?: RegistrationDTO | undefined;

    constructor(data?: IRegistrationByIdVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? RegistrationDTO.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegistrationByIdVM {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationByIdVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegistrationByIdVM {
    data?: RegistrationDTO | undefined;
}

export class CreateRegistrationCommand implements ICreateRegistrationCommand {
    id?: string;
    userId?: string | undefined;
    companyName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    planId?: number;
    password?: string | undefined;
    planExpiryDate?: Date;
    websiteUrl?: string | undefined;
    qualification?: string | undefined;
    filePath?: string | undefined;
    balance?: number;

    constructor(data?: ICreateRegistrationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.companyName = _data["companyName"];
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.planId = _data["planId"];
            this.password = _data["password"];
            this.planExpiryDate = _data["planExpiryDate"] ? new Date(_data["planExpiryDate"].toString()) : <any>undefined;
            this.websiteUrl = _data["websiteUrl"];
            this.qualification = _data["qualification"];
            this.filePath = _data["filePath"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): CreateRegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRegistrationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["companyName"] = this.companyName;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["planId"] = this.planId;
        data["password"] = this.password;
        data["planExpiryDate"] = this.planExpiryDate ? this.planExpiryDate.toISOString() : <any>undefined;
        data["websiteUrl"] = this.websiteUrl;
        data["qualification"] = this.qualification;
        data["filePath"] = this.filePath;
        data["balance"] = this.balance;
        return data; 
    }
}

export interface ICreateRegistrationCommand {
    id?: string;
    userId?: string | undefined;
    companyName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactEmail?: string | undefined;
    contactPhone?: string | undefined;
    planId?: number;
    password?: string | undefined;
    planExpiryDate?: Date;
    websiteUrl?: string | undefined;
    qualification?: string | undefined;
    filePath?: string | undefined;
    balance?: number;
}

export class UpdateRegistrationVerifiedCommand implements IUpdateRegistrationVerifiedCommand {
    userId?: string | undefined;
    isVerified?: boolean;

    constructor(data?: IUpdateRegistrationVerifiedCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.isVerified = _data["isVerified"];
        }
    }

    static fromJS(data: any): UpdateRegistrationVerifiedCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRegistrationVerifiedCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["isVerified"] = this.isVerified;
        return data; 
    }
}

export interface IUpdateRegistrationVerifiedCommand {
    userId?: string | undefined;
    isVerified?: boolean;
}

export class UpdateRegistrationCommand implements IUpdateRegistrationCommand {
    id?: string;
    companyName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactEmail?: string | undefined;
    contactOldEmail?: string | undefined;
    contactPhone?: string | undefined;
    planId?: number;
    planExpiryDate?: Date;
    websiteUrl?: string | undefined;
    qualification?: string | undefined;
    filePath?: string | undefined;
    balance?: number;

    constructor(data?: IUpdateRegistrationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
            this.contactFirstName = _data["contactFirstName"];
            this.contactLastName = _data["contactLastName"];
            this.contactEmail = _data["contactEmail"];
            this.contactOldEmail = _data["contactOldEmail"];
            this.contactPhone = _data["contactPhone"];
            this.planId = _data["planId"];
            this.planExpiryDate = _data["planExpiryDate"] ? new Date(_data["planExpiryDate"].toString()) : <any>undefined;
            this.websiteUrl = _data["websiteUrl"];
            this.qualification = _data["qualification"];
            this.filePath = _data["filePath"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): UpdateRegistrationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRegistrationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        data["contactFirstName"] = this.contactFirstName;
        data["contactLastName"] = this.contactLastName;
        data["contactEmail"] = this.contactEmail;
        data["contactOldEmail"] = this.contactOldEmail;
        data["contactPhone"] = this.contactPhone;
        data["planId"] = this.planId;
        data["planExpiryDate"] = this.planExpiryDate ? this.planExpiryDate.toISOString() : <any>undefined;
        data["websiteUrl"] = this.websiteUrl;
        data["qualification"] = this.qualification;
        data["filePath"] = this.filePath;
        data["balance"] = this.balance;
        return data; 
    }
}

export interface IUpdateRegistrationCommand {
    id?: string;
    companyName?: string | undefined;
    contactFirstName?: string | undefined;
    contactLastName?: string | undefined;
    contactEmail?: string | undefined;
    contactOldEmail?: string | undefined;
    contactPhone?: string | undefined;
    planId?: number;
    planExpiryDate?: Date;
    websiteUrl?: string | undefined;
    qualification?: string | undefined;
    filePath?: string | undefined;
    balance?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}